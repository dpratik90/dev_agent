This is a large project, and coding everything in a single go would be too large for a single response. I'll outline the basic structure of the project. Actual implementation depends heavily on project's specific requirements.

```
/project_root
  ├── README.md
  ├── requirements.txt
  ├── /app
      ├── __init__.py
      ├── main.py
      ├── config.py
      ├── database.py
      ├── /auth
          ├── __init__.py
          ├── auth_handler.py
      ├── /schemas
          ├── __init__.py
          ├── schemas.py
      ├── /models
          ├── __init__.py
          ├── models.py
      ├── /cruds
          ├── __init__.py
          ├── task.py
      /utils
          ├── __init__.py
          ├── helpers.py
```

1. requirements.txt:
```txt
fastapi
uvicorn
sqlalchemy
alembic
psycopg2
pyjwt
pydantic
```

2. main.py:
```python
from fastapi import FastAPI
from . import models
from .database import engine
from .routers import task

app = FastAPI()

models.Base.metadata.create_all(engine)

app.include_router(task.router)
```

3. database.py:
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "postgresql://user:password@localhost/dbname"

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

4. models/models.py:
```python
from sqlalchemy import Column, Integer, String
from .database import Base

class Task(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String, index=True)
```

5. schemas/schemas.py:
```python
from pydantic import BaseModel

class TaskBase(BaseModel):
    title: str
    description: str

class TaskCreate(TaskBase):
    pass

class Task(TaskBase):
    id: int

    class Config:
        orm_mode = True
```

6. auth/auth_handler.py:
```python
# JWT authentication related code
```

7. cruds/task.py:
```python
from sqlalchemy.orm import Session
from .. import models, schemas

def get_task(db: Session, task_id: int):
    return db.query(models.Task).filter(models.Task.id == task_id).first()
    
# Add more CRUD operations
```

8. utils/helpers.py:
```python
# Helper functions
```

9. config.py:
```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str = "postgresql://user:password@localhost/dbname"

settings = Settings()
```

Please expand upon each file based on your specific needs. While this project structure and base-code provides a solid starting point, much of the implementation (particularly auth/auth_handler.py and cruds/task.py) will vary significantly based on your specific use-case and requirements. For the JWT authentication, you would implement encoding and decoding of information, as well as including exceptions for incorrect tokens. As for the CRUD operations, include functions for creating, reading, updating, and deleting tasks.